<!doctype html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>drawer</title>
  <link rel="stylesheet" href="/style.css">
</head>

<body>
  <div id="app">
    <div id="sketch">
      <canvas class="whiteboard"></canvas>
    </div>
    
    <div class="tool-list">
      <!-- ペン -->
      <div class="icon inline-block" @click="tool(1)">
        <svg height="32" width="32" viewBox="0 0 128 128" xmlns="http://www.w3.org/2000/svg">
          <path
            d="m102.7 40.773-15.473-15.473a3.057 3.057 0 0 0 -4.227 0l-5.313 5.313-34.756 34.759-4.039 4.039h-.005l-5.311 5.31a2.947 2.947 0 0 0 -.5 3.532l-9.046 23.455a1.75 1.75 0 0 0 2.262 2.262l23.443-9.034a2.948 2.948 0 0 0 3.529-.5l5.315-5.316 34.756-34.758 4.04-4.039v-.005-.005l5.325-5.313a2.991 2.991 0 0 0 0-4.227zm-10.6 9.875-14.748-14.748 1.572-1.572 14.747 14.748zm-30.711 30.712-14.748-14.748 28.236-28.237 14.748 14.748zm-4.047 4.046-14.742-14.748 1.571-1.571 14.743 14.747zm-21.624-4.294 11.17 11.17-18.174 7zm15.434 10.488-14.752-14.751 3.716-3.716 14.752 14.748zm44.994-45-14.746-14.746 3.715-3.715 14.747 14.747z" />
        </svg>
      </div>

      <!-- マーカー -->
      <div class="icon inline-block" @click="tool(2)">
        <svg height="28" width="28" id="Capa_1" enable-background="new 0 0 512.047 512.047" viewBox="0 0 512.047 512.047"
          xmlns="http://www.w3.org/2000/svg">
          <g>
            <path
              d="m169.413 321.004c-22.557-3.187-46.298 3.872-63.61 21.184-40.394 40.395-76.673 72.902-105.803 98.899l24.52 8.211c32.479 10.878 81.602 21.186 118.699 20.724 32.384-.398 54.198-7.315 68.65-21.768 17.313-17.313 24.371-41.053 21.184-63.611l278.994-278.993-63.64-63.64zm21.243 106.037c-8.445 8.445-24.083 12.691-47.807 12.983-29.052.352-61.669-6.373-83.551-11.957 17.145-15.759 42.918-39.866 67.718-64.666 17.545-17.545 46.093-17.546 63.64 0 17.545 17.546 17.545 46.095 0 63.64zm21.213-84.853c-3.631-3.632-7.547-6.81-11.674-9.539l58.494-58.494 21.213 21.213-58.494 58.494c-2.73-4.127-5.908-8.042-9.539-11.674zm89.246-68.033-21.213-21.213 168.505-168.506 21.213 21.213z" />
          </g>
        </svg>
      </div>

      <!-- 消しゴム -->
      <div class="icon inline-block" @click="tool(3)">
        <?xml version="1.0" encoding="iso-8859-1"?>
        <!-- Generator: Adobe Illustrator 19.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
        <svg height="24" width="24" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px"
          y="0px" viewBox="0 0 433.25 433.25" style="enable-background:new 0 0 433.25 433.25;" xml:space="preserve">
          <g>
            <g>
              <path d="M418.4,192.331c19.8-19.8,19.8-51.9,0-71.7l-0.1-0.1l-78.6-78.3c-19.8-19.8-51.9-19.7-71.8,0l-169.5,169.6l-54.2,54.1
        			c-19.8,19.7-19.8,51.8-0.1,71.6l48.3,48.3H10c-5.5,0-10,4.5-10,10s4.5,10,10,10h297.4c5.5,0,10-4.5,10-10s-4.5-10-10-10H225
        			l23.9-23.7L418.4,192.331z M196.7,385.831h-76.1l-62.3-62.4c-12-12-11.9-31.4,0-43.4l47.1-47l122.2,122L196.7,385.831z
        			 M119.6,218.931l162.5-162.5c12-12,31.5-12,43.5,0l78.6,78.4c12,12,12,31.4,0,43.5l-162.4,162.8L119.6,218.931z" />
            </g>
          </g>
        </svg>
      </div>      

      <!-- <button @click="tool(1)">ペン</button>
      <button @click="tool(2)">マーカー</button>
      <button @click="tool(3)">消しゴム</button> -->

      <!-- クリア -->
      <div class="icon inline-block" @click="deleteCanvas()">
        <svg height="24" width="24" viewBox="-40 0 427 427.00131" xmlns="http://www.w3.org/2000/svg">
          <path
            d="m232.398438 154.703125c-5.523438 0-10 4.476563-10 10v189c0 5.519531 4.476562 10 10 10 5.523437 0 10-4.480469 10-10v-189c0-5.523437-4.476563-10-10-10zm0 0" />
          <path
            d="m114.398438 154.703125c-5.523438 0-10 4.476563-10 10v189c0 5.519531 4.476562 10 10 10 5.523437 0 10-4.480469 10-10v-189c0-5.523437-4.476563-10-10-10zm0 0" />
          <path
            d="m28.398438 127.121094v246.378906c0 14.5625 5.339843 28.238281 14.667968 38.050781 9.285156 9.839844 22.207032 15.425781 35.730469 15.449219h189.203125c13.527344-.023438 26.449219-5.609375 35.730469-15.449219 9.328125-9.8125 14.667969-23.488281 14.667969-38.050781v-246.378906c18.542968-4.921875 30.558593-22.835938 28.078124-41.863282-2.484374-19.023437-18.691406-33.253906-37.878906-33.257812h-51.199218v-12.5c.058593-10.511719-4.097657-20.605469-11.539063-28.03125-7.441406-7.421875-17.550781-11.5546875-28.0625-11.46875h-88.796875c-10.511719-.0859375-20.621094 4.046875-28.0625 11.46875-7.441406 7.425781-11.597656 17.519531-11.539062 28.03125v12.5h-51.199219c-19.1875.003906-35.394531 14.234375-37.878907 33.257812-2.480468 19.027344 9.535157 36.941407 28.078126 41.863282zm239.601562 279.878906h-189.203125c-17.097656 0-30.398437-14.6875-30.398437-33.5v-245.5h250v245.5c0 18.8125-13.300782 33.5-30.398438 33.5zm-158.601562-367.5c-.066407-5.207031 1.980468-10.21875 5.675781-13.894531 3.691406-3.675781 8.714843-5.695313 13.925781-5.605469h88.796875c5.210937-.089844 10.234375 1.929688 13.925781 5.605469 3.695313 3.671875 5.742188 8.6875 5.675782 13.894531v12.5h-128zm-71.199219 32.5h270.398437c9.941406 0 18 8.058594 18 18s-8.058594 18-18 18h-270.398437c-9.941407 0-18-8.058594-18-18s8.058593-18 18-18zm0 0" />
          <path
            d="m173.398438 154.703125c-5.523438 0-10 4.476563-10 10v189c0 5.519531 4.476562 10 10 10 5.523437 0 10-4.480469 10-10v-189c0-5.523437-4.476563-10-10-10zm0 0" />
        </svg>
      </div>
      <!-- <button @click="deleteCanvas()">消去</button> -->

      <!-- 黒、青、黄、赤 -->
      <div class="inline-block color-circle color-black" @click="changeColor(68, 68, 68)"></div>
      <div class="inline-block color-circle color-blue" @click="changeColor(153, 221, 255)"></div>
      <div class="inline-block color-circle color-yellow" @click="changeColor(255, 255, 187)"></div>
      <div class="inline-block color-circle color-red" @click="changeColor(255, 187, 187)"></div>
      
      <!-- <button @click="changeColor(68, 68, 68)">黒</button>
      <button @click="changeColor(153, 221, 255)">青</button>
      <button @click="changeColor(255, 255, 187)">黄</button>
      <button @click="changeColor(255, 187, 187)">赤</button> -->

      <!-- 線幅 -->
      <div class="inline-block pen-width-box" @click="changeLineWidth(3)">
        <div class="pen-width-s center"></div>
      </div>
      <div class="inline-block pen-width-box" @click="changeLineWidth(12)">
        <div class="pen-width-m center"></div>
      </div>
      <div class="inline-block pen-width-box" @click="changeLineWidth(24)">
        <div class="pen-width-l center"></div>
      </div>
      <!-- <button @click="changeLineWidth(3)">細</button>
            <button @click="changeLineWidth(12)">中</button>
            <button @click="changeLineWidth(24)">太</button> -->
      <!-- <input type="range" name="width" min="3" max="30" v-model="current.line_width"> -->

      <!-- <button @click="download()">ダウンロード</button> -->
      <!-- <a id="download" v-bind:href="base64" download="canvas.jpg">ダウンロード</a> -->

      <!-- <button @click="toSVG()">SVG</button> -->
    </div>

    <div class="room">
      <input type="text" size="10" v-model="room_id">
      <button @click="socketJoin()">join</button>
    </div>

    <!-- マウスストーカー -->
    <!-- <div id="stalker"></div> -->
  </div>
  

  <script src="/socket.io/socket.io.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <script src="/fabric.js"></script>
  <!-- <script src="/main.js"></script> -->

  <script>
    // https://socket.io/demos/whiteboard/
    // https://github.com/socketio/socket.io/tree/master/examples/whiteboard

    var socket = io()

    var app = new Vue({
      el: '#app',
      data: {
        canvas: '',
        context: '',
        tmp_canvas: '',
        tmp_context: '',
        drawing: false,
        current: {
          tool: '',
          line_width: 0,
          color: {
            rgba: '',
            r: 0,
            g: 0,
            b: 0,
            a: 0
          }
        },
        points: [],
        room_id: ''
      },
      mounted() {
        // // https://coliss.com/articles/build-websites/operation/css/viewport-units-on-mobile.html
        // // 最初に、ビューポートの高さを取得し、0.01を掛けて1%の値を算出して、vh単位の値を取得
        // let vh = window.innerHeight * 0.01
        // // カスタム変数--vhの値をドキュメントのルートに設定
        // document.documentElement.style.setProperty('--vh', `${vh}px`)

        this.canvas = document.getElementsByClassName('whiteboard')[0]
        // this.canvas = new fabric.Canvas('whiteboard', { isDrawingMode: true })
        this.context = this.canvas.getContext('2d')

        // Creating a tmp canvas
        this.tmp_canvas = document.createElement('canvas')
        this.tmp_context = this.tmp_canvas.getContext('2d')
        this.tmp_canvas.id = 'tmp_canvas'
        this.tmp_canvas.classList.add('whiteboard')
        // this.tmp_canvas.width = this.canvas.width
        // this.tmp_canvas.height = this.canvas.height
        const sketch = document.querySelector('#sketch')
        sketch.appendChild(this.tmp_canvas)

        window.addEventListener('resize', this.onResize, false)
        this.onResize()

        // ペン、太さ12、黒で初期設定
        this.tool(1)
        this.changeLineWidth(12)
        this.changeColor(68, 68, 68)
        this.drawing = false

        // 線の設定（固定値のもの）
        this.context.lineCap = 'round'
        this.context.lineJoin = 'round'
        this.tmp_context.shadowBlur = 1
        this.tmp_context.lineCap = 'round'
        this.tmp_context.lineJoin = 'round'

        this.tmp_canvas.addEventListener('mousedown', this.onMouseDown, false)
        this.tmp_canvas.addEventListener('mouseup', this.onMouseUp, false)
        this.tmp_canvas.addEventListener('mouseout', this.onMouseUp, false)
        this.tmp_canvas.addEventListener('mousemove', this.throttle(this.onMouseMove, 30), false)

        // Touch support for mobile devices
        this.tmp_canvas.addEventListener('touchstart', this.onMouseDown, false)
        this.tmp_canvas.addEventListener('touchend', this.onMouseUp, false)
        this.tmp_canvas.addEventListener('touchcancel', this.onMouseUp, false)
        this.tmp_canvas.addEventListener('touchmove', this.throttle(this.onMouseMove, 30), false)

        // socoket.ioからの信号を受けて、メソッドを呼ぶ
        socket.on('drawing', this.onDrawingEvent)
        socket.on('erasing', this.onErasingEvent)
        socket.on('drawImage', this.onDrawImage)
        socket.on('message', this.socketMessage)

        // マウスストーカー https://wemo.tech/3214
        // const stalker = document.getElementById('stalker')
        // document.addEventListener('mousemove', function(e) {
        //   stalker.style.transform = 'translate(' + e.clientX + 'px, ' + e.clientY + 'px)'
        // })
      },
      methods: {
        onMouseDown(e) {
          this.drawing = true
          this.points.length = 0

          // 開始点を設定
          this.points.push(
            {
              x: e.clientX || e.touches[0].clientX,
              y: e.clientY || e.touches[0].clientY
            }
          )
        },
        onMouseUp(e) {
          this.drawing = false
          this.points.length = 0

          if (this.current.tool === 3) {
            // 消しゴムの場合
          } else {
            this.doDrawImage()
            socket.emit('drawImage', {
              room_id: this.room_id
            })
          }
        },
        onMouseMove(e) {
          if (!this.drawing) { return }

          // 線の軌跡点を設定
          this.points.push(
            {
              x: e.clientX || e.touches[0].clientX,
              y: e.clientY || e.touches[0].clientY
            }
          )

          if(this.current.tool === 3) {
            // 消しゴムの場合
            this.eraseLine(this.points, this.current.line_width, this.current.color.rgba, true)
          } else {
            this.drawLine(this.points, this.current.line_width, this.current.color.rgba, true)
          }
        },
        throttle(callback, delay) {
          let previousCall = new Date().getTime()
          return function () {
            const time = new Date().getTime()

            if((time - previousCall) >= delay) {
              previousCall = time
              callback.apply(null, arguments)
            }
          }
        },
        drawLine(points, width, color, emit) {
          // ここを参考にquadraticCurveToでスムーズなラインを実装
          // http://perfectionkills.com/exploring-canvas-drawing-techniques/#bezier-curves

          let p1 = points[0]
          let p2 = points[1]

          this.tmp_context.lineWidth = width
          this.tmp_context.strokeStyle = color
          this.tmp_context.shadowColor = color
          
          // tmp_canvasをクリア
          this.tmp_context.clearRect(0, 0, this.tmp_context.canvas.width, this.tmp_context.canvas.height)

          this.tmp_context.beginPath()
          this.tmp_context.moveTo(p1.x, p1.y)

          for (let i = 1; i < points.length; i++) {
            // we pick the point between pi+1 & pi+2 as the end point and p1 as our control point
            let midPoint = this.midPointBtw(p1, p2)
            this.tmp_context.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y)
            p1 = points[i]
            p2 = points[i + 1]
          }
          // Draw last line as a straight line while
          // we wait for the next point to be able to calculate the bezier control point
          this.tmp_context.lineTo(p1.x, p1.y)
          this.tmp_context.stroke()

          // emitしない（false）場合はここで終了
          if (!emit) { return }

          const w = this.canvas.width
          const h = this.canvas.height
          const points_adjusted = points.map(p => ({
            x: p.x / w,
            y: p.y / h
          }))

          socket.emit('drawing', {
            room_id: this.room_id,
            points: points_adjusted,
            width: width,
            color: color
          })
        },
        eraseLine(points, width, color, emit) {
          let p1 = points[0]
          let p2 = points[1]

          this.context.lineWidth = width
          this.context.strokeStyle = color

          this.context.beginPath()
          this.context.moveTo(p1.x, p1.y)

          for (let i = 1; i < points.length; i++) {
            // we pick the point between pi+1 & pi+2 as the end point and p1 as our control point
            let midPoint = this.midPointBtw(p1, p2)
            this.context.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y)
            p1 = points[i]
            p2 = points[i + 1]
          }
          // Draw last line as a straight line while
          // we wait for the next point to be able to calculate the bezier control point
          this.context.lineTo(p1.x, p1.y)
          this.context.stroke()

          // emitしない（false）場合はここで終了
          if (!emit) { return }

          const w = this.canvas.width
          const h = this.canvas.height
          const points_adjusted = points.map(p => ({
            x: p.x / w,
            y: p.y / h
          }))

          socket.emit('erasing', {
            room_id: this.room_id,
            points: points_adjusted,
            width: width,
            color: color
          })
        },
        midPointBtw(p1, p2) {
          // http://perfectionkills.com/exploring-canvas-drawing-techniques/#bezier-curves
          return {
            x: p1.x + (p2.x - p1.x) / 2,
            y: p1.y + (p2.y - p1.y) / 2
          }
        },
        doDrawImage() {
          // tmp_canvasを実際のcanvasに転記
          this.context.drawImage(this.tmp_canvas, 0, 0)

          // tmp_canvasをクリア
          this.tmp_context.clearRect(0, 0, this.tmp_canvas.width, this.tmp_canvas.height)
        },
        onDrawingEvent(data) {
          this.tmp_context.globalCompositeOperation = 'source-over'
          this.context.globalCompositeOperation = 'source-over'

          const w = this.canvas.width
          const h = this.canvas.height
          const points_adjusted = data.points.map(p => ({
            x: p.x * w,
            y: p.y * h
          }))

          this.drawLine(points_adjusted, data.width, data.color, false)
        },
        onErasingEvent(data) {
          this.context.globalCompositeOperation = 'destination-out'

          const w = this.canvas.width
          const h = this.canvas.height
          const points_adjusted = data.points.map(p => ({
            x: p.x * w,
            y: p.y * h
          }))

          this.eraseLine(points_adjusted, data.width, data.color, false)
        },
        onDrawImage(data){
          this.doDrawImage()
        },
        onResize() {
          // let vh = window.innerHeight * 0.01
          // document.documentElement.style.setProperty('--vh', `${vh}px`)

          this.canvas.width = window.innerWidth
          this.canvas.height = window.innerHeight
          this.tmp_canvas.width = window.innerWidth
          this.tmp_canvas.height = window.innerHeight
        },
        tool(tool) {
          this.current.tool = tool
          switch (tool) {
            case 1:
              // ペン
              this.tmp_context.globalCompositeOperation = 'source-over'
              this.context.globalCompositeOperation = 'source-over'
              this.current.color.a = 0.95
              this.current.color.rgba = this.toRGBA()
              break
            case 2:
              // マーカー
              this.tmp_context.globalCompositeOperation = 'source-over'
              this.context.globalCompositeOperation = 'source-over'
              this.current.color.a = 0.3
              this.current.color.rgba = this.toRGBA()
              break
            case 3:
              // 消しゴム
              // 複数ウィンドウで同時描画するときに、ペン使用中に相手が消しゴムに切り替えて線が消える、ということがあるかもしれない
              this.tmp_context.globalCompositeOperation = 'destination-out'
              this.context.globalCompositeOperation = 'destination-out'
              this.current.color.a = 1.0
              this.current.color.rgba = this.toRGBA()
              break
            default:
              break
          }
        },
        deleteCanvas() {
          this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
          // confirm = confirm('canvasの内容を削除しますか？')
          // // アラートで「OK」を選んだ時
          // if (confirm === true) {
          //   this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
          // }
        },
        changeLineWidth(width) {
          this.current.line_width = width

          // マウスストーカーの直径を線幅に合わせ、中心点を調整
          // const stalker = document.getElementById('stalker')
          // stalker.style.width = this.current.line_width + 'px'
          // stalker.style.height = this.current.line_width + 'px'
          // stalker.style.top = -1 * this.current.line_width / 2 + 'px'
          // stalker.style.left = -1 * this.current.line_width / 2 + 'px'
        },
        changeColor(r, g, b) {
          this.current.color.r = r
          this.current.color.g = g
          this.current.color.b = b
          this.current.color.rgba = this.toRGBA()
        },
        toRGBA() {
          const rgba = 'rgba(' + this.current.color.r + ',' + this.current.color.g + ',' + this.current.color.b + ',' + this.current.color.a + ')'
          
          // const stalker = document.getElementById('stalker')
          // stalker.style.borderColor = rgba
          // stalker.style.backgroundColor = rgba

          // rgba(0, 0, 0, 1.0)形式の文字列を返す
          return rgba
        },
        // download() {
        //   let a = document.createElement('a')
        //   a.href = this.canvas.toDataURL('image/png')
        //   a.download = 'download.jpg'
        //   a.click()
        // },
        socketJoin(data) {
          socket.emit('join', {
            room_id: this.room_id
            // name: this.name
          })
        },
        socketMessage(data) {
          console.log(data)
        },
        // toSVG() {
        //   // let canvas = new fabric.Canvas('canvas')
        //   // console.log(canvas)
        //   // canvas.add(new fabric.Rect({
        //   //   left: 250,
        //   //   top: 250,
        //   //   height: 200,
        //   //   width: 200,
        //   //   fill: 'green'
        //   // }))
        //   // console.log(canvas)
        //   // console.log(canvas.toSVG())
        //   // console.log(this.canvas.toSVG())

        //   this.canvas.isDrawingMode = false
        //   console.log(this.canvas)
        //   console.log(this.canvas.toSVG())
        // }
      }
    })
  </script>
</body>
</html>
