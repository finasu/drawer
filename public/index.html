<!doctype html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <title>Socket.IO whiteboard</title>
  <link rel="stylesheet" href="/style.css">
</head>

<body>
  <div id="app" class="h-100-vh">
    <div id="sketch">
      <canvas class="whiteboard"></canvas>
      <canvas id="canvas" width="600" height="500"></canvas>
    </div>
    
    <div class="tool-list">
      <button @click="changeLineWidth(3)">細</button>
      <button @click="changeLineWidth(12)">中</button>
      <button @click="changeLineWidth(24)">太</button>
      <!-- <input type="range" name="width" min="3" max="30" v-model="current.line_width"> -->

      <button @click="tool(1)">ペン</button>
      <button @click="tool(2)">マーカー</button>
      <button @click="tool(3)">消しゴム</button>

      <button @click="deleteCanvas()">消去</button>
      
      <button @click="changeColor(68, 68, 68)">黒</button>
      <button @click="changeColor(153, 221, 255)">青</button>
      <button @click="changeColor(255, 255, 187)">黄</button>
      <button @click="changeColor(255, 187, 187)">赤</button>

      <button @click="download()">ダウンロード</button>
      <!-- <a id="download" v-bind:href="base64" download="canvas.jpg">ダウンロード</a> -->

      <button @click="toSVG()">SVG</button>

      <button @click="socketJoin()">join</button>
      <input type="text" size="10" v-model="room_id">
    </div>

    <!-- マウスストーカー -->
    <div id="stalker"></div>
  </div>
  

  <script src="/socket.io/socket.io.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <script src="/fabric.js"></script>
  <!-- <script src="/main.js"></script> -->

  <script>
    // https://socket.io/demos/whiteboard/
    // https://github.com/socketio/socket.io/tree/master/examples/whiteboard

    var socket = io()

    var app = new Vue({
      el: '#app',
      data: {
        canvas: '',
        context: '',
        tmp_canvas: '',
        tmp_context: '',
        drawing: false,
        current: {
          tool: '',
          line_width: 0,
          color: {
            rgba: '',
            r: 0,
            g: 0,
            b: 0,
            a: 0
          }
        },
        points: [],
        room_id: ''
      },
      mounted() {
        // https://coliss.com/articles/build-websites/operation/css/viewport-units-on-mobile.html
        // 最初に、ビューポートの高さを取得し、0.01を掛けて1%の値を算出して、vh単位の値を取得
        let vh = window.innerHeight * 0.01
        // カスタム変数--vhの値をドキュメントのルートに設定
        document.documentElement.style.setProperty('--vh', `${vh}px`)

        this.canvas = document.getElementsByClassName('whiteboard')[0]
        // this.canvas = new fabric.Canvas('whiteboard', { isDrawingMode: true })
        this.context = this.canvas.getContext('2d')

        window.addEventListener('resize', this.onResize, false)
        this.onResize()

        // Creating a tmp canvas
        this.tmp_canvas = document.createElement('canvas')
        this.tmp_context = this.tmp_canvas.getContext('2d')
        this.tmp_canvas.classList.add('whiteboard')
        this.tmp_canvas.width = this.canvas.width
        this.tmp_canvas.height = this.canvas.height
        const sketch = document.querySelector('#sketch')
        sketch.appendChild(this.tmp_canvas)

        // ペン、太さ12、黒で初期設定
        this.tool(1)
        this.changeLineWidth(12)
        this.changeColor(68, 68, 68)
        this.drawing = false

        // 線の設定（固定値のもの）
        this.context.lineCap = 'round'
        this.context.lineJoin = 'round'
        this.tmp_context.shadowBlur = 1
        this.tmp_context.lineCap = 'round'
        this.tmp_context.lineJoin = 'round'

        this.tmp_canvas.addEventListener('mousedown', this.onMouseDown, false)
        this.tmp_canvas.addEventListener('mouseup', this.onMouseUp, false)
        this.tmp_canvas.addEventListener('mouseout', this.onMouseUp, false)
        this.tmp_canvas.addEventListener('mousemove', this.throttle(this.onMouseMove, 30), false)

        // Touch support for mobile devices
        this.tmp_canvas.addEventListener('touchstart', this.onMouseDown, false)
        this.tmp_canvas.addEventListener('touchend', this.onMouseUp, false)
        this.tmp_canvas.addEventListener('touchcancel', this.onMouseUp, false)
        this.tmp_canvas.addEventListener('touchmove', this.throttle(this.onMouseMove, 30), false)

        // socoket.ioからの信号を受けて、メソッドを呼ぶ
        socket.on('drawing', this.onDrawingEvent)
        socket.on('erasing', this.onErasingEvent)
        socket.on('drawImage', this.onDrawImage)
        socket.on('message', this.socketMessage)

        // マウスストーカー https://wemo.tech/3214
        const stalker = document.getElementById('stalker')
        document.addEventListener('mousemove', function(e) {
          stalker.style.transform = 'translate(' + e.clientX + 'px, ' + e.clientY + 'px)'
        })
      },
      methods: {
        onMouseDown(e) {
          this.drawing = true
          this.points.length = 0

          // 開始点を設定
          this.points.push(
            {
              x: e.clientX || e.touches[0].clientX,
              y: e.clientY || e.touches[0].clientY
            }
          )
        },
        onMouseUp(e) {
          this.drawing = false
          this.points.length = 0

          if (this.current.tool === 3) {
            // 消しゴムの場合
          } else {
            this.doDrawImage()
            socket.emit('drawImage', {
              room_id: this.room_id
            })
          }
        },
        onMouseMove(e) {
          if (!this.drawing) { return }

          // 線の軌跡点を設定
          this.points.push(
            {
              x: e.clientX || e.touches[0].clientX,
              y: e.clientY || e.touches[0].clientY
            }
          )

          if(this.current.tool === 3) {
            // 消しゴムの場合
            this.eraseLine(this.points, this.current.line_width, this.current.color.rgba, true)
          } else {
            this.drawLine(this.points, this.current.line_width, this.current.color.rgba, true)
          }
        },
        throttle(callback, delay) {
          let previousCall = new Date().getTime()
          return function () {
            const time = new Date().getTime()

            if((time - previousCall) >= delay) {
              previousCall = time
              callback.apply(null, arguments)
            }
          }
        },
        drawLine(points, width, color, emit) {
          // ここを参考にquadraticCurveToでスムーズなラインを実装
          // http://perfectionkills.com/exploring-canvas-drawing-techniques/#bezier-curves

          let p1 = points[0]
          let p2 = points[1]

          this.tmp_context.lineWidth = width
          this.tmp_context.strokeStyle = color
          this.tmp_context.shadowColor = color
          
          // tmp_canvasをクリア
          this.tmp_context.clearRect(0, 0, this.tmp_context.canvas.width, this.tmp_context.canvas.height)

          this.tmp_context.beginPath()
          this.tmp_context.moveTo(p1.x, p1.y)

          for (let i = 1; i < points.length; i++) {
            // we pick the point between pi+1 & pi+2 as the end point and p1 as our control point
            let midPoint = this.midPointBtw(p1, p2)
            this.tmp_context.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y)
            p1 = points[i]
            p2 = points[i + 1]
          }
          // Draw last line as a straight line while
          // we wait for the next point to be able to calculate the bezier control point
          this.tmp_context.lineTo(p1.x, p1.y)
          this.tmp_context.stroke()

          // emitしない（false）場合はここで終了
          if (!emit) { return }

          const w = this.canvas.width
          const h = this.canvas.height
          const points_adjusted = points.map(p => ({
            x: p.x / w,
            y: p.y / h
          }))

          socket.emit('drawing', {
            room_id: this.room_id,
            points: points_adjusted,
            width: width,
            color: color
          })
        },
        eraseLine(points, width, color, emit) {
          let p1 = points[0]
          let p2 = points[1]

          this.context.lineWidth = width
          this.context.strokeStyle = color

          this.context.beginPath()
          this.context.moveTo(p1.x, p1.y)

          for (let i = 1; i < points.length; i++) {
            // we pick the point between pi+1 & pi+2 as the end point and p1 as our control point
            let midPoint = this.midPointBtw(p1, p2)
            this.context.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y)
            p1 = points[i]
            p2 = points[i + 1]
          }
          // Draw last line as a straight line while
          // we wait for the next point to be able to calculate the bezier control point
          this.context.lineTo(p1.x, p1.y)
          this.context.stroke()

          // emitしない（false）場合はここで終了
          if (!emit) { return }

          const w = this.canvas.width
          const h = this.canvas.height
          const points_adjusted = points.map(p => ({
            x: p.x / w,
            y: p.y / h
          }))

          socket.emit('erasing', {
            room_id: this.room_id,
            points: points_adjusted,
            width: width,
            color: color
          })
        },
        midPointBtw(p1, p2) {
          // http://perfectionkills.com/exploring-canvas-drawing-techniques/#bezier-curves
          return {
            x: p1.x + (p2.x - p1.x) / 2,
            y: p1.y + (p2.y - p1.y) / 2
          }
        },
        doDrawImage() {
          // tmp_canvasを実際のcanvasに転記
          this.context.drawImage(this.tmp_canvas, 0, 0)

          // tmp_canvasをクリア
          this.tmp_context.clearRect(0, 0, this.tmp_canvas.width, this.tmp_canvas.height)
        },
        onDrawingEvent(data) {
          this.tmp_context.globalCompositeOperation = 'source-over'
          this.context.globalCompositeOperation = 'source-over'

          const w = this.canvas.width
          const h = this.canvas.height
          const points_adjusted = data.points.map(p => ({
            x: p.x * w,
            y: p.y * h
          }))

          this.drawLine(points_adjusted, data.width, data.color, false)
        },
        onErasingEvent(data) {
          this.context.globalCompositeOperation = 'destination-out'

          const w = this.canvas.width
          const h = this.canvas.height
          const points_adjusted = data.points.map(p => ({
            x: p.x * w,
            y: p.y * h
          }))

          this.eraseLine(points_adjusted, data.width, data.color, false)
        },
        onDrawImage(data){
          this.doDrawImage()
        },
        onResize() {
          let vh = window.innerHeight * 0.01
          document.documentElement.style.setProperty('--vh', `${vh}px`)

          this.canvas.width = window.innerWidth
          this.canvas.height = window.innerHeight
        },
        tool(tool) {
          this.current.tool = tool
          switch (tool) {
            case 1:
              // ペン
              this.tmp_context.globalCompositeOperation = 'source-over'
              this.context.globalCompositeOperation = 'source-over'
              this.current.color.a = 0.95
              this.current.color.rgba = this.toRGBA()
              break
            case 2:
              // マーカー
              this.tmp_context.globalCompositeOperation = 'source-over'
              this.context.globalCompositeOperation = 'source-over'
              this.current.color.a = 0.3
              this.current.color.rgba = this.toRGBA()
              break
            case 3:
              // 消しゴム
              // 複数ウィンドウで同時描画するときに、ペン使用中に相手が消しゴムに切り替えて線が消える、ということがあるかもしれない
              this.tmp_context.globalCompositeOperation = 'destination-out'
              this.context.globalCompositeOperation = 'destination-out'
              this.current.color.a = 1.0
              this.current.color.rgba = this.toRGBA()
              break
            default:
              break
          }
        },
        deleteCanvas() {
          this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
          // confirm = confirm('canvasの内容を削除しますか？')
          // // アラートで「OK」を選んだ時
          // if (confirm === true) {
          //   this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
          // }
        },
        changeLineWidth(width) {
          this.current.line_width = width

          // マウスストーカーの直径を線幅に合わせ、中心点を調整
          const stalker = document.getElementById('stalker')
          stalker.style.width = this.current.line_width + 'px'
          stalker.style.height = this.current.line_width + 'px'
          stalker.style.top = -1 * this.current.line_width / 2 + 'px'
          stalker.style.left = -1 * this.current.line_width / 2 + 'px'
        },
        changeColor(r, g, b) {
          this.current.color.r = r
          this.current.color.g = g
          this.current.color.b = b
          this.current.color.rgba = this.toRGBA()
        },
        toRGBA() {
          const rgba = 'rgba(' + this.current.color.r + ',' + this.current.color.g + ',' + this.current.color.b + ',' + this.current.color.a + ')'
          
          const stalker = document.getElementById('stalker')
          stalker.style.borderColor = rgba
          stalker.style.backgroundColor = rgba

          // rgba(0, 0, 0, 1.0)形式の文字列を返す
          return rgba
        },
        download() {
          let a = document.createElement('a')
          a.href = this.canvas.toDataURL('image/png')
          a.download = 'download.jpg'
          a.click()
        },
        socketJoin(data) {
          socket.emit('join', {
            room_id: this.room_id
            // name: this.name
          })
        },
        socketMessage(data) {
          console.log(data)
        },
        toSVG() {
          // let canvas = new fabric.Canvas('canvas')
          // console.log(canvas)
          // canvas.add(new fabric.Rect({
          //   left: 250,
          //   top: 250,
          //   height: 200,
          //   width: 200,
          //   fill: 'green'
          // }))
          // console.log(canvas)
          // console.log(canvas.toSVG())
          // console.log(this.canvas.toSVG())

          this.canvas.isDrawingMode = false
          console.log(this.canvas)
          console.log(this.canvas.toSVG())
        }
      }
    })
  </script>
</body>
</html>
