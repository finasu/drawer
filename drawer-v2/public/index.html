<!doctype html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <title>Socket.IO whiteboard</title>
  <link rel="stylesheet" href="/style.css">
</head>

<body>
  <div id="app">
    <div id="sketch">
      <canvas class="whiteboard"></canvas>
    </div>
    
    <div class="tool-list">
      <button @click="changeLineWidth(3)">細</button>
      <button @click="changeLineWidth(12)">中</button>
      <button @click="changeLineWidth(24)">太</button>
      <!-- <input type="range" name="width" min="3" max="30" v-model="line_width"> -->

      <button @click="tool(1)">ペン</button>
      <button @click="tool(2)">マーカー</button>
      <button @click="tool(3)">消しゴム</button>

      <button @click="deleteCanvas()">消去</button>
      
      <button @click="changeColor(1)">黒</button>
      <button @click="changeColor(2)">青</button>
      <button @click="changeColor(3)">黄</button>
      <button @click="changeColor(4)">赤</button>

      <button @click="download()">ダウンロード</button>
      <!-- <a id="download" v-bind:href="base64" download="canvas.jpg">ダウンロード</a> -->
    </div>
  </div>
  

  <script src="/socket.io/socket.io.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <!-- <script src="/main.js"></script> -->

  <script>
    // https://socket.io/demos/whiteboard/
    // https://github.com/socketio/socket.io/tree/master/examples/whiteboard

    var socket = io()

    var app = new Vue({
      el: '#app',
      data: {
        canvas: '',
        context: '',
        tmp_canvas: '',
        tmp_context: '',
        current: {
          line_width: 12,
          color: {
            rgba: '',
            r: 68,
            g: 68,
            b: 68,
            a: 0.95
          },
          tool: ''
        },
        drawing: false,
        points: []
      },
      mounted() {
        this.canvas = document.getElementsByClassName('whiteboard')[0]
        this.context = this.canvas.getContext('2d')
        // this.context = this.$el.getContext('2d')

        window.addEventListener('resize', this.onResize, false)
        this.onResize()

        const sketch = document.querySelector('#sketch')
        // var sketch_style = getComputedStyle(sketch)
        // this.canvas.width = parseInt(sketch_style.getPropertyValue('width'))
        // this.canvas.height = parseInt(sketch_style.getPropertyValue('height'))

        // Creating a tmp canvas
        this.tmp_canvas = document.createElement('canvas')
        this.tmp_context = this.tmp_canvas.getContext('2d')
        this.tmp_canvas.classList.add('whiteboard')
        this.tmp_canvas.width = this.canvas.width
        this.tmp_canvas.height = this.canvas.height
        sketch.appendChild(this.tmp_canvas)

        this.drawing = false

        // ペン、太さ12、黒で初期設定
        this.tool(1)
        this.changeLineWidth(12)
        this.changeColor(1)

        // 線の設定（固定値のもの）
        this.context.lineCap = 'round'
        this.context.lineJoin = 'round'
        this.tmp_context.shadowBlur = 1
        this.tmp_context.lineCap = 'round'
        this.tmp_context.lineJoin = 'round'

        this.tmp_canvas.addEventListener('mousedown', this.onMouseDown, false)
        this.tmp_canvas.addEventListener('mouseup', this.onMouseUp, false)
        // this.tmp_canvas.addEventListener('mouseout', this.onMouseUp, false)
        this.tmp_canvas.addEventListener('mousemove', this.throttle(this.onMouseMove, 20), false)

        // Touch support for mobile devices
        this.tmp_canvas.addEventListener('touchstart', this.onMouseDown, false)
        this.tmp_canvas.addEventListener('touchend', this.onMouseUp, false)
        // this.tmp_canvas.addEventListener('touchcancel', this.onMouseUp, false)
        this.tmp_canvas.addEventListener('touchmove', this.throttle(this.onMouseMove, 20), false)

        socket.on('drawing', this.onDrawingEvent)
        socket.on('erasing', this.onErasingEvent)
        socket.on('drawImage', this.onDrawImage)
      },
      methods: {
        onMouseDown(e) {
          // this.drawing = true
          // this.current.x = e.clientX || e.touches[0].clientX
          // this.current.y = e.clientY || e.touches[0].clientY
          
          this.drawing = true

          // 開始点を設定
          this.points.push(
            {
              x: e.clientX || e.touches[0].clientX,
              y: e.clientY || e.touches[0].clientY
            }
          )
        },
        onMouseUp(e) {
          // if (!this.drawing) { return }
          // this.drawing = false
          // this.drawLine(this.current.x, this.current.y, e.clientX || e.touches[0].clientX, e.clientY || e.touches[0].clientY, this.current.color.rgba, true)
          
          this.drawing = false
          this.points.length = 0


          if (this.current.tool === 3) {
            // 消しゴムの場合
            
          } else {
            this.doDrawImage()
            socket.emit('drawImage', {})
          }

          // // tmp_canvasを実際のcanvasに転記
          // this.context.drawImage(this.tmp_canvas, 0, 0)

          // // tmp_canvasをクリア
          // this.tmp_context.clearRect(0, 0, this.tmp_canvas.width, this.tmp_canvas.height)
        },
        onMouseMove(e) {
          // if (!this.drawing) { return }
          // this.drawLine(this.current.x, this.current.y, e.clientX || e.touches[0].clientX, e.clientY || e.touches[0].clientY, this.current.color.rgba, true)
          // this.current.x = e.clientX || e.touches[0].clientX
          // this.current.y = e.clientY || e.touches[0].clientY
          
          if (!this.drawing) { return }

          // 線の軌跡点を設定
          this.points.push(
            {
              x: e.clientX || e.touches[0].clientX,
              y: e.clientY || e.touches[0].clientY
            }
          )

          // // これはdrawLineのなかでやっていい処理かも、そうすればdrawLineにはpointsだけ渡せば良くなる（p1, p2を渡す必要がない）
          // let p1 = this.points[0]
          // let p2 = this.points[1]

          if(this.current.tool === 3) {
            // 消しゴムの場合
            // this.eraseLine(p1, p2, this.points, this.current.line_width, this.current.color.rgba, true)
            this.eraseLine(this.points, this.current.line_width, this.current.color.rgba, true)
          } else {
            // this.drawLine(p1, p2, this.points, this.current.line_width, this.current.color.rgba, true)
            this.drawLine(this.points, this.current.line_width, this.current.color.rgba, true)
          }
        },
        throttle(callback, delay) {
          let previousCall = new Date().getTime()
          return function () {
            const time = new Date().getTime()

            if((time - previousCall) >= delay) {
              previousCall = time
              callback.apply(null, arguments)
            }
          }
        },
        drawLine(points, width, color, emit) {
          // ここを参考にquadraticCurveToでスムーズなラインを実装
          // http://perfectionkills.com/exploring-canvas-drawing-techniques/#bezier-curves

          let p1 = points[0]
          let p2 = points[1]

          const p1_emit = p1
          const p2_emit = p2

          // this.tmp_context.lineWidth = this.current.line_width
          this.tmp_context.lineWidth = width
          // this.tmp_context.strokeStyle = this.current.color.rgba
          this.tmp_context.strokeStyle = color
          // this.tmp_context.shadowColor = this.current.color.rgba
          this.tmp_context.shadowColor = color
          
          // tmp_canvasをクリア
          this.tmp_context.clearRect(0, 0, this.tmp_context.canvas.width, this.tmp_context.canvas.height)

          this.tmp_context.beginPath()
          this.tmp_context.moveTo(p1.x, p1.y)

          for (let i = 1; i < points.length; i++) {
            // we pick the point between pi+1 & pi+2 as the
            // end point and p1 as our control point
            let midPoint = this.midPointBtw(p1, p2)
            this.tmp_context.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y)
            p1 = points[i]
            p2 = points[i + 1]
          }
          // Draw last line as a straight line while
          // we wait for the next point to be able to calculate
          // the bezier control point
          this.tmp_context.lineTo(p1.x, p1.y)
          this.tmp_context.stroke()

          // emitしない（false）場合はここで終了
          if (!emit) { return }

          const w = this.canvas.width
          const h = this.canvas.height

          // p1_emit.x = Number(p1_emit.x) / w
          // p1_emit.y = Number(p1_emit.y) / h
          // p2_emit.x = Number(p2_emit.x) / w
          // p2_emit.y = Number(p2_emit.y) / h
          // const points_adjusted = points.map(p => ({
          //   x: p.x / w,
          //   y: p.y / h
          // }))

          // socket.emit('drawing', {
          //   p1: p1_emit,
          //   p2: p2_emit,
          //   points: points,
          //   width: width,
          //   color: color
          // })
          socket.emit('drawing', {
            points: points,
            width: width,
            color: color
          })
        },
        eraseLine(points, width, color, emit) {
          let p1 = points[0]
          let p2 = points[1]

          const p1_emit = p1
          const p2_emit = p2

          this.context.lineWidth = width
          this.context.strokeStyle = color

          this.context.beginPath()
          this.context.moveTo(p1.x, p1.y)

          for (let i = 1; i < points.length; i++) {
            // we pick the point between pi+1 & pi+2 as the
            // end point and p1 as our control point
            let midPoint = this.midPointBtw(p1, p2)
            this.context.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y)
            p1 = points[i]
            p2 = points[i + 1]
          }
          // Draw last line as a straight line while
          // we wait for the next point to be able to calculate
          // the bezier control point
          this.context.lineTo(p1.x, p1.y)
          this.context.stroke()

          // emitしない（false）場合はここで終了
          if (!emit) { return }

          // socket.emit('erasing', {
          //   p1: p1_emit,
          //   p2: p2_emit,
          //   points: points,
          //   width: width,
          //   color: color
          // })
          socket.emit('erasing', {
            points: points,
            width: width,
            color: color
          })
        },
        // drawLine(x0, y0, x1, y1, color, emit) {
        //   this.context.lineWidth = this.current.line_width
        //   this.context.strokeStyle = color
        //   // this.context.shadowBlur = 1
        //   // this.context.shadowColor = color
        //   this.context.lineCap = 'round'
        //   this.context.lineJoin = 'round'

        //   this.context.beginPath()
        //   this.context.moveTo(x0, y0)
        //   this.context.lineTo(x1, y1)
        //   this.context.stroke()
        //   this.context.closePath()

        //   if (!emit) { return }
        //   var w = this.canvas.width
        //   var h = this.canvas.height

        //   socket.emit('drawing', {
        //     x0: x0 / w,
        //     y0: y0 / h,
        //     x1: x1 / w,
        //     y1: y1 / h,
        //     color: color
        //   })
        // },
        doDrawImage() {
          // tmp_canvasを実際のcanvasに転記
          this.context.drawImage(this.tmp_canvas, 0, 0)

          // tmp_canvasをクリア
          this.tmp_context.clearRect(0, 0, this.tmp_canvas.width, this.tmp_canvas.height)
        },
        onDrawingEvent(data) {
          this.tmp_context.globalCompositeOperation = 'source-over'
          this.context.globalCompositeOperation = 'source-over'

          const w = this.canvas.width
          const h = this.canvas.height

          // data.p1.x = data.p1.x * w
          // data.p1.y = data.p1.y * h
          // data.p2.x = data.p2.x * w
          // data.p2.y = data.p2.y * h
          // const points_adjusted = data.points.map(p => ({
          //   x: p.x * w,
          //   y: p.y * h
          // }))

          // this.drawLine(data.x0 * w, data.y0 * h, data.x1 * w, data.y1 * h, data.color)
          // this.drawLine(data.p1, data.p2, data.points, data.width, data.color, false)
          this.drawLine(data.points, data.width, data.color, false)
        },
        onErasingEvent(data) {
          this.context.globalCompositeOperation = 'destination-out'

          // this.eraseLine(data.p1, data.p2, data.points, data.width, data.color, false)
          this.eraseLine(data.points, data.width, data.color, false)
        },
        onDrawImage(data){
          this.doDrawImage()
        },
        onResize() {
          this.canvas.width = window.innerWidth
          this.canvas.height = window.innerHeight
        },
        tool(tool) {
          this.current.tool = tool
          switch (tool) {
            case 1:
              // ペン
              this.tmp_context.globalCompositeOperation = 'source-over'
              this.context.globalCompositeOperation = 'source-over'
              this.current.color.a = 0.95
              this.current.color.rgba = this.toRGBA()
              break
            case 2:
              // マーカー
              this.tmp_context.globalCompositeOperation = 'source-over'
              this.context.globalCompositeOperation = 'source-over'
              this.current.color.a = 0.3
              this.current.color.rgba = this.toRGBA()
              break
            case 3:
              // 消しゴム
              // 複数ウィンドウで同時描画するときに、ペン使用中に相手が消しゴムに切り替えて線が消える、ということがあるかもしれない
              this.tmp_context.globalCompositeOperation = 'destination-out'
              this.context.globalCompositeOperation = 'destination-out'
              this.current.color.a = 1.0
              this.current.color.rgba = this.toRGBA()
              break
            default:
              break
          }
        },
        deleteCanvas() {
          this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
          // confirm = confirm('canvasの内容を削除しますか？')
          // // アラートで「OK」を選んだ時
          // if (confirm === true) {
          //   this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
          // }
        },
        changeLineWidth(width) {
          this.current.line_width = width
        },
        changeColor(color_num) {
          switch (color_num) {
            case 1:
              // 黒
              this.current.color.r = 68
              this.current.color.g = 68
              this.current.color.b = 68
              break
            case 2:
              // 青
              this.current.color.r = 153
              this.current.color.g = 221
              this.current.color.b = 255
              break
            case 3:
              // 黄
              this.current.color.r = 255
              this.current.color.g = 255
              this.current.color.b = 187
              break
            case 4:
              // 赤
              this.current.color.r = 255
              this.current.color.g = 187
              this.current.color.b = 187
              break
            default:
              break
          }
          this.current.color.rgba = this.toRGBA()
        },
        toRGBA() {
          // rgba(0, 0, 0, 1.0)形式の文字列を返す
          return 'rgba(' + this.current.color.r + ',' + this.current.color.g + ',' + this.current.color.b + ',' + this.current.color.a + ')'
        },
        download() {
          let a = document.createElement('a')
          a.href = this.canvas.toDataURL('image/png')
          a.download = 'download.jpg'
          a.click()
        },
        // http://perfectionkills.com/exploring-canvas-drawing-techniques/#bezier-curves
        midPointBtw(p1, p2) {
          return {
            x: p1.x + (p2.x - p1.x) / 2,
            y: p1.y + (p2.y - p1.y) / 2
          }
        }
      }
    })
  </script>
</body>
</html>
